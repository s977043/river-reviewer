---
id: riverbed-memory
title: Riverbed Memory
---

## 概要

Riverbed Memory は、コンテキストを保持するためのレイヤーです。川底が過去の流れの痕跡を保持するように、アーキテクチャ上の決定、WontFix 項目、過去のレビュー結果を記憶し、River Reviewer が PR やリリース間で一貫性を保てるようにします。流れを安定させる軽量で監査可能な記憶層と捉えてください。

## スコープ (v0 → v1 → v2)

- **v0: ステートレス (現在)**—永続化されたコンテキストはなく、各レビューは独立している。
- **v1: 最小限のメモリ**—PR コメントに構造化されたメタデータを埋め込むか、次の実行のための決定/リンクをキャプチャする実行ごとの JSON アーティファクトを保存する。
- **v2: 外部化されたメモリ (スケッチ)**—リポジトリ間の想起や長期間の履歴を必要とするチーム向けの、オプションの Postgres/Redis/ベクターストア バックエンド。

## ストレージオプション

- **隠しマーカー付き GitHub PR コメント**: 検査は容易で、再実行後も残る。サイズの制限はあるものの、ノイズの多い通知を避けるようにする。
- **GitHub Artifacts (PR ごとの .json)**: 安価で監査可能。スナップショットに適しているが、保持ポリシー次第で期限切れになる。
- **`.river/` 配下のリポジトリファイル**: コードと一緒に配置され、バージョン管理される。頻繁に書き込まれるとチャーンやマージ競合を招き、管理コスト上昇の要因となる可能性がある。
- **外部データストア (Postgres/Redis/vector DB)**: スケーラブルで意味的な想起を可能にする一方、運用のオーバーヘッドとシークレット管理が追加される。

## 設計トレードオフ

- **コスト**: コメントは無料、アーティファクトは安価、外部ストアはインフラコストが発生する。
- **複雑さ**: コメント/アーティファクトは単純。リポジトリファイルは書き込みパスとマージ戦略が必要。外部 DB はサービスとローテーションが必要。
- **セキュリティ**: コメント/アーティファクトは GitHub スコープ内に存在。リポジトリファイルはリポジトリ ACL を継承する。外部ストアはシークレット処理とネットワークポリシーが必要。
- **監査可能性**: コメントとリポジトリファイルは人間が読める。アーティファクトは検索可能。外部ストアは明示的な保持/バックアップが必要。

## 次のアクション (v1 に向けて)

1. JSON にシリアル化できる最小限のメモリレコードスキーマ（例: Issue ID、ADR リンク、または WontFix の根拠）を定義する。
2. レコードをアーティファクトとして出力し、許可されている場合は隠しマーカー付きのコンパクトな PR コメントを出力するオプションの GitHub Action ステップを追加する。
3. エージェントに、各実行で最後に利用可能なアーティファクト/コメントを取り込み、レビューをブロックすることなくプロンプトコンテキストにマージするように教える。
